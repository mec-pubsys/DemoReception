{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nexport var searchAddressFromPostalCode = function () {\n  var _ref = _asyncToGenerator(function* (postalCode) {\n    var state;\n    var city;\n    try {\n      var response = yield fetch(`https://zipcloud.ibsnet.co.jp/api/search?zipcode=${postalCode}`);\n      var json = yield response.json();\n      if (!json.results || !postalCode) {\n        throw new Error(\"Postal code not found\");\n      }\n      if (json.status !== 200) {\n        throw new Error(\"Response error\");\n      }\n      var _convertJsonToStrAddr = convertJsonToStrAddress(json);\n      var _convertJsonToStrAddr2 = _slicedToArray(_convertJsonToStrAddr, 2);\n      state = _convertJsonToStrAddr2[0];\n      city = _convertJsonToStrAddr2[1];\n      return [state, city];\n    } catch (error) {\n      throw error;\n    }\n  });\n  return function searchAddressFromPostalCode(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar convertJsonToStrAddress = function convertJsonToStrAddress(json) {\n  var state = json.results[0].address1;\n  var majorCity = json.results[0].address2;\n  var minorCities = json.results.map(function (result) {\n    return result.address3;\n  });\n  var minorCity = joinMinorCities(minorCities);\n  var city = majorCity + minorCity;\n  return [state, city];\n};\nvar joinMinorCities = function joinMinorCities(minorCities) {\n  if (minorCities.length === 1) {\n    return minorCities[0];\n  }\n  var commonPrefix = findCommonPrefix(minorCities);\n  var uniqueMinorCities = minorCities.map(function (city) {\n    return city.replace(commonPrefix, \"\");\n  });\n  var filteredUniqueCities = uniqueMinorCities.filter(function (city) {\n    return city.trim() !== \"\";\n  });\n  var joinedCities = filteredUniqueCities.join(\"、\");\n  var result = commonPrefix + joinedCities;\n  return result;\n};\nvar findCommonPrefix = function findCommonPrefix(strings) {\n  if (!strings || strings.length === 0) {\n    return \"\";\n  }\n  var sortedStrings = strings.slice().sort();\n  var first = sortedStrings[0];\n  var last = sortedStrings[sortedStrings.length - 1];\n  var minLength = Math.min(first.length, last.length);\n  var i = 0;\n  while (i < minLength && first.charAt(i) === last.charAt(i)) {\n    i++;\n  }\n  return first.substring(0, i);\n};","map":{"version":3,"names":["searchAddressFromPostalCode","_ref","_asyncToGenerator","postalCode","state","city","response","fetch","json","results","Error","status","_convertJsonToStrAddr","convertJsonToStrAddress","_convertJsonToStrAddr2","_slicedToArray","error","_x","apply","arguments","address1","majorCity","address2","minorCities","map","result","address3","minorCity","joinMinorCities","length","commonPrefix","findCommonPrefix","uniqueMinorCities","replace","filteredUniqueCities","filter","trim","joinedCities","join","strings","sortedStrings","slice","sort","first","last","minLength","Math","min","i","charAt","substring"],"sources":["/home/runner/work/DemoReception/DemoReception/example/src/environments/InputMethods.ts"],"sourcesContent":["export const searchAddressFromPostalCode = async (postalCode: any) => {\n  let state;\n  let city;\n  try {\n    const response = await fetch(\n      `https://zipcloud.ibsnet.co.jp/api/search?zipcode=${postalCode}`\n    );\n    const json = await response.json();\n\n    // Handle cases where address is not found or _post is empty\n    if (!json.results || !postalCode) {\n      throw new Error(\"Postal code not found\");\n    }\n\n    // Handle response errors\n    if (json.status !== 200) {\n      throw new Error(\"Response error\");\n    }\n\n    // Convert JSON to state and city\n    [state, city] = convertJsonToStrAddress(json);\n\n    return [state, city];\n  } catch (error) {\n    throw error;\n  }\n};\n\nconst convertJsonToStrAddress = (json: { results: any[] }) => {\n  // Extract state from address1\n  const state = json.results[0].address1;\n\n  // Extract major city from address2\n  const majorCity = json.results[0].address2;\n\n  // Extract minor cities from address3\n  const minorCities = json.results.map(\n    (result: { address3: any }) => result.address3\n  );\n\n  // Join minor cities into a single string\n  const minorCity = joinMinorCities(minorCities);\n\n  // Concatenate major city and minor city to get the full city name\n  const city = majorCity + minorCity;\n\n  return [state, city];\n};\n\nconst joinMinorCities = (minorCities: any[]) => {\n  // If only one minor city, return it directly\n  if (minorCities.length === 1) {\n    return minorCities[0];\n  }\n\n  // Find the common part among all minor cities\n  const commonPrefix = findCommonPrefix(minorCities);\n\n  // Remove the common part from each minor city\n  const uniqueMinorCities = minorCities.map((city: string) =>\n    city.replace(commonPrefix, \"\")\n  );\n\n  // Filter out empty strings\n  const filteredUniqueCities = uniqueMinorCities.filter(\n    (city: string) => city.trim() !== \"\"\n  );\n\n  // Join unique minor cities with commas\n  const joinedCities = filteredUniqueCities.join(\"、\");\n\n  // Combine common part and unique minor cities\n  const result = commonPrefix + joinedCities;\n\n  return result;\n};\n\nconst findCommonPrefix = (strings: any[]) => {\n  if (!strings || strings.length === 0) {\n    return \"\";\n  }\n\n  const sortedStrings = strings.slice().sort();\n  const first = sortedStrings[0];\n  const last = sortedStrings[sortedStrings.length - 1];\n  const minLength = Math.min(first.length, last.length);\n\n  let i = 0;\n  while (i < minLength && first.charAt(i) === last.charAt(i)) {\n    i++;\n  }\n\n  return first.substring(0, i);\n};\n"],"mappings":";;AAAA,OAAO,IAAMA,2BAA2B;EAAA,IAAAC,IAAA,GAAAC,iBAAA,CAAG,WAAOC,UAAe,EAAK;IACpE,IAAIC,KAAK;IACT,IAAIC,IAAI;IACR,IAAI;MACF,IAAMC,QAAQ,SAASC,KAAK,CACzB,oDAAmDJ,UAAW,EACjE,CAAC;MACD,IAAMK,IAAI,SAASF,QAAQ,CAACE,IAAI,CAAC,CAAC;MAGlC,IAAI,CAACA,IAAI,CAACC,OAAO,IAAI,CAACN,UAAU,EAAE;QAChC,MAAM,IAAIO,KAAK,CAAC,uBAAuB,CAAC;MAC1C;MAGA,IAAIF,IAAI,CAACG,MAAM,KAAK,GAAG,EAAE;QACvB,MAAM,IAAID,KAAK,CAAC,gBAAgB,CAAC;MACnC;MAAC,IAAAE,qBAAA,GAGeC,uBAAuB,CAACL,IAAI,CAAC;MAAA,IAAAM,sBAAA,GAAAC,cAAA,CAAAH,qBAAA;MAA5CR,KAAK,GAAAU,sBAAA;MAAET,IAAI,GAAAS,sBAAA;MAEZ,OAAO,CAACV,KAAK,EAAEC,IAAI,CAAC;IACtB,CAAC,CAAC,OAAOW,KAAK,EAAE;MACd,MAAMA,KAAK;IACb;EACF,CAAC;EAAA,gBA1BYhB,2BAA2BA,CAAAiB,EAAA;IAAA,OAAAhB,IAAA,CAAAiB,KAAA,OAAAC,SAAA;EAAA;AAAA,GA0BvC;AAED,IAAMN,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAAIL,IAAwB,EAAK;EAE5D,IAAMJ,KAAK,GAAGI,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC,CAACW,QAAQ;EAGtC,IAAMC,SAAS,GAAGb,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC,CAACa,QAAQ;EAG1C,IAAMC,WAAW,GAAGf,IAAI,CAACC,OAAO,CAACe,GAAG,CAClC,UAACC,MAAyB;IAAA,OAAKA,MAAM,CAACC,QAAQ;EAAA,CAChD,CAAC;EAGD,IAAMC,SAAS,GAAGC,eAAe,CAACL,WAAW,CAAC;EAG9C,IAAMlB,IAAI,GAAGgB,SAAS,GAAGM,SAAS;EAElC,OAAO,CAACvB,KAAK,EAAEC,IAAI,CAAC;AACtB,CAAC;AAED,IAAMuB,eAAe,GAAG,SAAlBA,eAAeA,CAAIL,WAAkB,EAAK;EAE9C,IAAIA,WAAW,CAACM,MAAM,KAAK,CAAC,EAAE;IAC5B,OAAON,WAAW,CAAC,CAAC,CAAC;EACvB;EAGA,IAAMO,YAAY,GAAGC,gBAAgB,CAACR,WAAW,CAAC;EAGlD,IAAMS,iBAAiB,GAAGT,WAAW,CAACC,GAAG,CAAC,UAACnB,IAAY;IAAA,OACrDA,IAAI,CAAC4B,OAAO,CAACH,YAAY,EAAE,EAAE,CAAC;EAAA,CAChC,CAAC;EAGD,IAAMI,oBAAoB,GAAGF,iBAAiB,CAACG,MAAM,CACnD,UAAC9B,IAAY;IAAA,OAAKA,IAAI,CAAC+B,IAAI,CAAC,CAAC,KAAK,EAAE;EAAA,CACtC,CAAC;EAGD,IAAMC,YAAY,GAAGH,oBAAoB,CAACI,IAAI,CAAC,GAAG,CAAC;EAGnD,IAAMb,MAAM,GAAGK,YAAY,GAAGO,YAAY;EAE1C,OAAOZ,MAAM;AACf,CAAC;AAED,IAAMM,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIQ,OAAc,EAAK;EAC3C,IAAI,CAACA,OAAO,IAAIA,OAAO,CAACV,MAAM,KAAK,CAAC,EAAE;IACpC,OAAO,EAAE;EACX;EAEA,IAAMW,aAAa,GAAGD,OAAO,CAACE,KAAK,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;EAC5C,IAAMC,KAAK,GAAGH,aAAa,CAAC,CAAC,CAAC;EAC9B,IAAMI,IAAI,GAAGJ,aAAa,CAACA,aAAa,CAACX,MAAM,GAAG,CAAC,CAAC;EACpD,IAAMgB,SAAS,GAAGC,IAAI,CAACC,GAAG,CAACJ,KAAK,CAACd,MAAM,EAAEe,IAAI,CAACf,MAAM,CAAC;EAErD,IAAImB,CAAC,GAAG,CAAC;EACT,OAAOA,CAAC,GAAGH,SAAS,IAAIF,KAAK,CAACM,MAAM,CAACD,CAAC,CAAC,KAAKJ,IAAI,CAACK,MAAM,CAACD,CAAC,CAAC,EAAE;IAC1DA,CAAC,EAAE;EACL;EAEA,OAAOL,KAAK,CAACO,SAAS,CAAC,CAAC,EAAEF,CAAC,CAAC;AAC9B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}