{"ast":null,"code":"'use strict';\n\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { ReanimatedError } from \"../errors.js\";\nvar INDEX_X = 0;\nvar INDEX_Y = 1;\nvar INDEX_Z = 2;\nfunction validateTransformOrigin(transformOrigin) {\n  'worklet';\n\n  if (transformOrigin.length !== 3) {\n    throw new ReanimatedError('Transform origin must have exactly 3 values.');\n  }\n  var _transformOrigin = _slicedToArray(transformOrigin, 3),\n    x = _transformOrigin[0],\n    y = _transformOrigin[1],\n    z = _transformOrigin[2];\n  if (!(typeof x === 'number' || typeof x === 'string' && x.endsWith('%'))) {\n    throw new ReanimatedError(`Transform origin x-position must be a number or a percentage string. Passed value: ${x}.`);\n  }\n  if (!(typeof y === 'number' || typeof y === 'string' && y.endsWith('%'))) {\n    throw new ReanimatedError(`Transform origin y-position must be a number or a percentage string. Passed value: ${y}.`);\n  }\n  if (typeof z !== 'number') {\n    throw new ReanimatedError(`Transform origin z-position must be a number. Passed value: ${z}.`);\n  }\n}\nexport function processTransformOrigin(transformOriginIn) {\n  'worklet';\n\n  var transformOrigin = Array.isArray(transformOriginIn) ? transformOriginIn : ['50%', '50%', 0];\n  if (typeof transformOriginIn === 'string') {\n    var transformOriginString = transformOriginIn;\n    var regex = /(top|bottom|left|right|center|\\d+(?:%|px)|0)/gi;\n    var transformOriginArray = ['50%', '50%', 0];\n    var index = INDEX_X;\n    var matches;\n    while (matches = regex.exec(transformOriginString)) {\n      var nextIndex = index + 1;\n      var value = matches[0];\n      var valueLower = value.toLowerCase();\n      switch (valueLower) {\n        case 'left':\n        case 'right':\n          {\n            if (index !== INDEX_X) {\n              throw new ReanimatedError(`Transform-origin ${value} can only be used for x-position`);\n            }\n            transformOriginArray[INDEX_X] = valueLower === 'left' ? 0 : '100%';\n            break;\n          }\n        case 'top':\n        case 'bottom':\n          {\n            if (index === INDEX_Z) {\n              throw new ReanimatedError(`Transform-origin ${value} can only be used for y-position`);\n            }\n            transformOriginArray[INDEX_Y] = valueLower === 'top' ? 0 : '100%';\n            if (index === INDEX_X) {\n              var horizontal = regex.exec(transformOriginString);\n              if (horizontal == null) {\n                break;\n              }\n              switch (horizontal == null ? void 0 : horizontal[0].toLowerCase()) {\n                case 'left':\n                  transformOriginArray[INDEX_X] = 0;\n                  break;\n                case 'right':\n                  transformOriginArray[INDEX_X] = '100%';\n                  break;\n                case 'center':\n                  transformOriginArray[INDEX_X] = '50%';\n                  break;\n                default:\n                  throw new ReanimatedError(`Could not parse transform-origin: ${transformOriginString}`);\n              }\n              nextIndex = INDEX_Z;\n            }\n            break;\n          }\n        case 'center':\n          {\n            if (index === INDEX_Z) {\n              throw new ReanimatedError(`Transform-origin value ${value} cannot be used for z-position`);\n            }\n            transformOriginArray[index] = '50%';\n            break;\n          }\n        default:\n          {\n            if (value.endsWith('%')) {\n              transformOriginArray[index] = value;\n            } else {\n              var numericValue = parseFloat(value);\n              if (isNaN(numericValue)) {\n                throw new ReanimatedError(`Invalid numeric value in transform-origin: ${value}`);\n              }\n              transformOriginArray[index] = numericValue;\n            }\n            break;\n          }\n      }\n      index = nextIndex;\n    }\n    transformOrigin = transformOriginArray;\n  }\n  if (typeof transformOriginIn !== 'string' && !Array.isArray(transformOriginIn)) {\n    throw new ReanimatedError(`Invalid transformOrigin type: ${typeof transformOriginIn}`);\n  }\n  if (__DEV__) {\n    validateTransformOrigin(transformOrigin);\n  }\n  return transformOrigin;\n}","map":{"version":3,"names":["_slicedToArray","ReanimatedError","INDEX_X","INDEX_Y","INDEX_Z","validateTransformOrigin","transformOrigin","length","_transformOrigin","x","y","z","endsWith","processTransformOrigin","transformOriginIn","Array","isArray","transformOriginString","regex","transformOriginArray","index","matches","exec","nextIndex","value","valueLower","toLowerCase","horizontal","numericValue","parseFloat","isNaN","__DEV__"],"sources":["/home/runner/work/DemoReception/DemoReception/example/node_modules/react-native-reanimated/src/updateProps/processTransformOrigin.ts"],"sourcesContent":["'use strict';\nimport { ReanimatedError } from '../errors';\n\nconst INDEX_X = 0;\nconst INDEX_Y = 1;\nconst INDEX_Z = 2;\n\n// Implementation based on https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/StyleSheet/processTransformOrigin.js\nfunction validateTransformOrigin(transformOrigin: Array<string | number>) {\n  'worklet';\n  if (transformOrigin.length !== 3) {\n    throw new ReanimatedError('Transform origin must have exactly 3 values.');\n  }\n  const [x, y, z] = transformOrigin;\n  if (!(typeof x === 'number' || (typeof x === 'string' && x.endsWith('%')))) {\n    throw new ReanimatedError(\n      `Transform origin x-position must be a number or a percentage string. Passed value: ${x}.`\n    );\n  }\n  if (!(typeof y === 'number' || (typeof y === 'string' && y.endsWith('%')))) {\n    throw new ReanimatedError(\n      `Transform origin y-position must be a number or a percentage string. Passed value: ${y}.`\n    );\n  }\n  if (typeof z !== 'number') {\n    throw new ReanimatedError(\n      `Transform origin z-position must be a number. Passed value: ${z}.`\n    );\n  }\n}\n\nexport function processTransformOrigin(\n  transformOriginIn: Array<string | number> | string | undefined\n): Array<string | number> {\n  'worklet';\n  let transformOrigin: Array<string | number> = Array.isArray(transformOriginIn)\n    ? transformOriginIn\n    : ['50%', '50%', 0];\n\n  if (typeof transformOriginIn === 'string') {\n    const transformOriginString = transformOriginIn;\n    const regex = /(top|bottom|left|right|center|\\d+(?:%|px)|0)/gi;\n    const transformOriginArray: Array<string | number> = ['50%', '50%', 0];\n\n    let index = INDEX_X;\n    let matches;\n    while ((matches = regex.exec(transformOriginString))) {\n      let nextIndex = index + 1;\n\n      const value = matches[0];\n      const valueLower = value.toLowerCase();\n\n      switch (valueLower) {\n        case 'left':\n        case 'right': {\n          if (index !== INDEX_X) {\n            throw new ReanimatedError(\n              `Transform-origin ${value} can only be used for x-position`\n            );\n          }\n          transformOriginArray[INDEX_X] = valueLower === 'left' ? 0 : '100%';\n          break;\n        }\n        case 'top':\n        case 'bottom': {\n          if (index === INDEX_Z) {\n            throw new ReanimatedError(\n              `Transform-origin ${value} can only be used for y-position`\n            );\n          }\n          transformOriginArray[INDEX_Y] = valueLower === 'top' ? 0 : '100%';\n\n          // Handle [[ center | left | right ] && [ center | top | bottom ]] <length>?\n          if (index === INDEX_X) {\n            const horizontal = regex.exec(transformOriginString);\n            if (horizontal == null) {\n              break;\n            }\n\n            switch (horizontal?.[0].toLowerCase()) {\n              case 'left':\n                transformOriginArray[INDEX_X] = 0;\n                break;\n              case 'right':\n                transformOriginArray[INDEX_X] = '100%';\n                break;\n              case 'center':\n                transformOriginArray[INDEX_X] = '50%';\n                break;\n              default:\n                throw new ReanimatedError(\n                  `Could not parse transform-origin: ${transformOriginString}`\n                );\n            }\n            nextIndex = INDEX_Z;\n          }\n\n          break;\n        }\n        case 'center': {\n          if (index === INDEX_Z) {\n            throw new ReanimatedError(\n              `Transform-origin value ${value} cannot be used for z-position`\n            );\n          }\n          transformOriginArray[index] = '50%';\n          break;\n        }\n        default: {\n          if (value.endsWith('%')) {\n            transformOriginArray[index] = value;\n          } else {\n            const numericValue = parseFloat(value);\n            if (isNaN(numericValue)) {\n              throw new ReanimatedError(\n                `Invalid numeric value in transform-origin: ${value}`\n              );\n            }\n            transformOriginArray[index] = numericValue;\n          }\n          break;\n        }\n      }\n\n      index = nextIndex;\n    }\n\n    transformOrigin = transformOriginArray;\n  }\n\n  if (\n    typeof transformOriginIn !== 'string' &&\n    !Array.isArray(transformOriginIn)\n  ) {\n    throw new ReanimatedError(\n      `Invalid transformOrigin type: ${typeof transformOriginIn}`\n    );\n  }\n\n  if (__DEV__) {\n    validateTransformOrigin(transformOrigin);\n  }\n\n  return transformOrigin;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}