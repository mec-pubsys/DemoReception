{"ast":null,"code":"'use strict';\n\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useRef, useState } from 'react';\nimport { getShadowNodeWrapperFromRef } from \"../fabricUtils\";\nimport { makeMutable } from \"../mutables.js\";\nimport { isFabric, isIOS, isMacOS, shouldBeUseWeb } from \"../PlatformChecker.js\";\nimport { findNodeHandle } from \"../platformFunctions/findNodeHandle\";\nimport { shareableMappingCache } from \"../shareableMappingCache.js\";\nimport { makeShareableCloneRecursive } from \"../shareables.js\";\nvar SHOULD_BE_USE_WEB = shouldBeUseWeb();\nfunction getComponentOrScrollable(component) {\n  if (component.getNativeScrollRef) {\n    return component.getNativeScrollRef();\n  }\n  if (component.getScrollableNode) {\n    return component.getScrollableNode();\n  }\n  return component;\n}\nfunction useAnimatedRefBase(getWrapper) {\n  var observers = useRef(new Map()).current;\n  var tagOrWrapperRef = useRef(-1);\n  var ref = useRef(null);\n  if (!ref.current) {\n    var fun = function fun(component) {\n      if (component) {\n        tagOrWrapperRef.current = getWrapper(component);\n        fun.getTag = function () {\n          return findNodeHandle(getComponentOrScrollable(component));\n        };\n        fun.current = component;\n        if (observers.size) {\n          var _fun$getTag;\n          var currentTag = (_fun$getTag = fun == null ? void 0 : fun.getTag == null ? void 0 : fun.getTag()) != null ? _fun$getTag : null;\n          observers.forEach(function (cleanup, observer) {\n            cleanup == null ? void 0 : cleanup();\n            observers.set(observer, observer(currentTag));\n          });\n        }\n      }\n      return tagOrWrapperRef.current;\n    };\n    fun.observe = function (observer) {\n      var _fun$getTag2;\n      var cleanup = observer((_fun$getTag2 = fun == null ? void 0 : fun.getTag == null ? void 0 : fun.getTag()) != null ? _fun$getTag2 : null);\n      observers.set(observer, cleanup);\n      return function () {\n        var _observers$get;\n        (_observers$get = observers.get(observer)) == null ? void 0 : _observers$get();\n        observers.delete(observer);\n      };\n    };\n    fun.current = null;\n    ref.current = fun;\n  }\n  return ref.current;\n}\nvar IS_APPLE = isIOS() || isMacOS();\nfunction useAnimatedRefNative() {\n  var _useState = useState(function () {\n      return !isFabric() && IS_APPLE ? makeMutable(null) : null;\n    }),\n    _useState2 = _slicedToArray(_useState, 1),\n    viewName = _useState2[0];\n  var _useState3 = useState(function () {\n      return makeMutable(null);\n    }),\n    _useState4 = _slicedToArray(_useState3, 1),\n    tagOrWrapper = _useState4[0];\n  var ref = useAnimatedRefBase(function (component) {\n    var getTagOrWrapper = isFabric() ? getShadowNodeWrapperFromRef : findNodeHandle;\n    tagOrWrapper.value = getTagOrWrapper(getComponentOrScrollable(component));\n    if (viewName) {\n      var _component$viewConfig;\n      viewName.value = (component == null ? void 0 : (_component$viewConfig = component.viewConfig) == null ? void 0 : _component$viewConfig.uiViewClassName) || 'RCTView';\n    }\n    return tagOrWrapper.value;\n  });\n  if (!shareableMappingCache.get(ref)) {\n    var animatedRefShareableHandle = makeShareableCloneRecursive({\n      __init: function __init() {\n        'worklet';\n\n        var f = function f() {\n          return tagOrWrapper.value;\n        };\n        if (viewName) {\n          f.viewName = viewName;\n        }\n        return f;\n      }\n    });\n    shareableMappingCache.set(ref, animatedRefShareableHandle);\n  }\n  return ref;\n}\nfunction useAnimatedRefWeb() {\n  return useAnimatedRefBase(function (component) {\n    return getComponentOrScrollable(component);\n  });\n}\nexport var useAnimatedRef = SHOULD_BE_USE_WEB ? useAnimatedRefWeb : useAnimatedRefNative;","map":{"version":3,"names":["_slicedToArray","useRef","useState","getShadowNodeWrapperFromRef","makeMutable","isFabric","isIOS","isMacOS","shouldBeUseWeb","findNodeHandle","shareableMappingCache","makeShareableCloneRecursive","SHOULD_BE_USE_WEB","getComponentOrScrollable","component","getNativeScrollRef","getScrollableNode","useAnimatedRefBase","getWrapper","observers","Map","current","tagOrWrapperRef","ref","fun","getTag","size","_fun$getTag","currentTag","forEach","cleanup","observer","set","observe","_fun$getTag2","_observers$get","get","delete","IS_APPLE","useAnimatedRefNative","_useState","_useState2","viewName","_useState3","_useState4","tagOrWrapper","getTagOrWrapper","value","_component$viewConfig","viewConfig","uiViewClassName","animatedRefShareableHandle","__init","f","useAnimatedRefWeb","useAnimatedRef"],"sources":["/home/runner/work/DemoReception/DemoReception/example/node_modules/react-native-reanimated/src/hook/useAnimatedRef.ts"],"sourcesContent":["'use strict';\nimport type { Component } from 'react';\nimport { useRef, useState } from 'react';\nimport type { FlatList, ScrollView } from 'react-native';\n\nimport type { ShadowNodeWrapper } from '../commonTypes';\nimport { getShadowNodeWrapperFromRef } from '../fabricUtils';\nimport { makeMutable } from '../mutables';\nimport { isFabric, isIOS, isMacOS, shouldBeUseWeb } from '../PlatformChecker';\nimport { findNodeHandle } from '../platformFunctions/findNodeHandle';\nimport { shareableMappingCache } from '../shareableMappingCache';\nimport { makeShareableCloneRecursive } from '../shareables';\nimport type {\n  AnimatedRef,\n  AnimatedRefObserver,\n  AnimatedRefOnUI,\n  MaybeObserverCleanup,\n} from './commonTypes';\n\nconst SHOULD_BE_USE_WEB = shouldBeUseWeb();\n\ninterface MaybeScrollableComponent extends Component {\n  getNativeScrollRef?: FlatList['getNativeScrollRef'];\n  getScrollableNode?:\n    | ScrollView['getScrollableNode']\n    | FlatList['getScrollableNode'];\n  viewConfig?: {\n    uiViewClassName?: string;\n  };\n}\n\nfunction getComponentOrScrollable(component: MaybeScrollableComponent) {\n  if (component.getNativeScrollRef) {\n    return component.getNativeScrollRef();\n  }\n  if (component.getScrollableNode) {\n    return component.getScrollableNode();\n  }\n  return component;\n}\n\nfunction useAnimatedRefBase<TComponent extends Component>(\n  getWrapper: (component: TComponent) => ShadowNodeWrapper | number | null\n): AnimatedRef<TComponent> {\n  const observers = useRef<Map<AnimatedRefObserver, MaybeObserverCleanup>>(\n    new Map()\n  ).current;\n  const tagOrWrapperRef = useRef<ShadowNodeWrapper | number | null>(-1);\n\n  const ref = useRef<AnimatedRef<TComponent> | null>(null);\n\n  if (!ref.current) {\n    const fun: AnimatedRef<TComponent> = <AnimatedRef<TComponent>>((\n      component\n    ) => {\n      if (component) {\n        tagOrWrapperRef.current = getWrapper(component);\n\n        // We have to unwrap the tag from the shadow node wrapper.\n        fun.getTag = () => findNodeHandle(getComponentOrScrollable(component));\n        fun.current = component;\n\n        if (observers.size) {\n          const currentTag = fun?.getTag?.() ?? null;\n          observers.forEach((cleanup, observer) => {\n            // Perform the cleanup before calling the observer again.\n            // This ensures that all events that were set up in the observer\n            // are cleaned up before the observer sets up new events during\n            // the next call.\n            cleanup?.();\n            observers.set(observer, observer(currentTag));\n          });\n        }\n      }\n\n      return tagOrWrapperRef.current;\n    });\n\n    fun.observe = (observer: AnimatedRefObserver) => {\n      // Call observer immediately to get the initial value\n      const cleanup = observer(fun?.getTag?.() ?? null);\n      observers.set(observer, cleanup);\n\n      return () => {\n        observers.get(observer)?.();\n        observers.delete(observer);\n      };\n    };\n\n    fun.current = null;\n    ref.current = fun;\n  }\n\n  return ref.current;\n}\n\nconst IS_APPLE = isIOS() || isMacOS();\n\nfunction useAnimatedRefNative<\n  TComponent extends Component,\n>(): AnimatedRef<TComponent> {\n  const [viewName] = useState(() =>\n    // viewName is required only on iOS/MacOS with Paper\n    !isFabric() && IS_APPLE ? makeMutable<string | null>(null) : null\n  );\n  const [tagOrWrapper] = useState(() =>\n    makeMutable<ShadowNodeWrapper | number | null>(null)\n  );\n\n  const ref = useAnimatedRefBase<TComponent>((component) => {\n    const getTagOrWrapper = isFabric()\n      ? getShadowNodeWrapperFromRef\n      : findNodeHandle;\n\n    tagOrWrapper.value = getTagOrWrapper(getComponentOrScrollable(component));\n\n    if (viewName) {\n      viewName.value =\n        (component as MaybeScrollableComponent)?.viewConfig?.uiViewClassName ||\n        'RCTView';\n    }\n\n    return tagOrWrapper.value;\n  });\n\n  if (!shareableMappingCache.get(ref)) {\n    const animatedRefShareableHandle = makeShareableCloneRecursive({\n      __init: () => {\n        'worklet';\n        const f: AnimatedRefOnUI = () => tagOrWrapper.value;\n        if (viewName) {\n          f.viewName = viewName;\n        }\n        return f;\n      },\n    });\n    shareableMappingCache.set(ref, animatedRefShareableHandle);\n  }\n\n  return ref;\n}\n\nfunction useAnimatedRefWeb<\n  TComponent extends Component,\n>(): AnimatedRef<TComponent> {\n  return useAnimatedRefBase<TComponent>((component) =>\n    getComponentOrScrollable(component)\n  );\n}\n\n/**\n * Lets you get a reference of a view that you can use inside a worklet.\n *\n * @returns An object with a `.current` property which contains an instance of a\n *   component.\n * @see https://docs.swmansion.com/react-native-reanimated/docs/core/useAnimatedRef\n */\nexport const useAnimatedRef = SHOULD_BE_USE_WEB\n  ? useAnimatedRefWeb\n  : useAnimatedRefNative;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}