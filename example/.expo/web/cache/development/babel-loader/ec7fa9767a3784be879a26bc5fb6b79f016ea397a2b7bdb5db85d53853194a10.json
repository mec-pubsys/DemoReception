{"ast":null,"code":"'use strict';\nimport { ReanimatedError } from \"./errors.js\";\nvar isLength = function isLength(value) {\n  'worklet';\n\n  return value.endsWith('px') || !isNaN(Number(value));\n};\nfunction parseBoxShadowString(rawBoxShadows) {\n  'worklet';\n\n  var result = [];\n  for (var rawBoxShadow of rawBoxShadows.split(/,(?![^()]*\\))/).map(function (bS) {\n    return bS.trim();\n  }).filter(function (bS) {\n    return bS !== '';\n  })) {\n    var boxShadow = {\n      offsetX: 0,\n      offsetY: 0\n    };\n    var offsetX = null;\n    var offsetY = null;\n    var keywordDetectedAfterLength = false;\n    var lengthCount = 0;\n    var args = rawBoxShadow.split(/\\s+(?![^(]*\\))/);\n    for (var arg of args) {\n      if (isLength(arg)) {\n        switch (lengthCount) {\n          case 0:\n            offsetX = arg;\n            lengthCount++;\n            break;\n          case 1:\n            if (keywordDetectedAfterLength) {\n              return [];\n            }\n            offsetY = arg;\n            lengthCount++;\n            break;\n          case 2:\n            if (keywordDetectedAfterLength) {\n              return [];\n            }\n            boxShadow.blurRadius = arg;\n            lengthCount++;\n            break;\n          case 3:\n            if (keywordDetectedAfterLength) {\n              return [];\n            }\n            boxShadow.spreadDistance = arg;\n            lengthCount++;\n            break;\n          default:\n            return [];\n        }\n      } else if (arg === 'inset') {\n        if (boxShadow.inset) {\n          return [];\n        }\n        if (offsetX !== null) {\n          keywordDetectedAfterLength = true;\n        }\n        boxShadow.inset = true;\n        continue;\n      } else {\n        if (boxShadow.color) {\n          return [];\n        }\n        if (offsetX != null) {\n          keywordDetectedAfterLength = true;\n        }\n        boxShadow.color = arg;\n        continue;\n      }\n    }\n    if (offsetX === null || offsetY === null) {\n      return [];\n    }\n    boxShadow.offsetX = offsetX;\n    boxShadow.offsetY = offsetY;\n    result.push(boxShadow);\n  }\n  return result;\n}\nfunction parseLength(length) {\n  'worklet';\n  var argsWithUnitsRegex = /([+-]?\\d*(\\.\\d+)?)([\\w\\W]+)?/g;\n  var match = argsWithUnitsRegex.exec(length);\n  if (!match || !isLength(length)) {\n    return null;\n  }\n  return Number(match[1]);\n}\nexport function processBoxShadow(props) {\n  'worklet';\n\n  var result = [];\n  var rawBoxShadows = props.boxShadow;\n  if (rawBoxShadows === null) {\n    return result;\n  }\n  var boxShadowList;\n  if (typeof rawBoxShadows === 'string') {\n    boxShadowList = parseBoxShadowString(rawBoxShadows.replace(/\\n/g, ' '));\n  } else if (Array.isArray(rawBoxShadows)) {\n    boxShadowList = rawBoxShadows;\n  } else {\n    throw new ReanimatedError(`Box shadow value must be an array of shadow objects or a string. Received: ${JSON.stringify(rawBoxShadows)}`);\n  }\n  for (var rawBoxShadow of boxShadowList) {\n    var parsedBoxShadow = {\n      offsetX: 0,\n      offsetY: 0\n    };\n    var value = void 0;\n    for (var arg in rawBoxShadow) {\n      switch (arg) {\n        case 'offsetX':\n          value = typeof rawBoxShadow.offsetX === 'string' ? parseLength(rawBoxShadow.offsetX) : rawBoxShadow.offsetX;\n          if (value === null) {\n            return [];\n          }\n          parsedBoxShadow.offsetX = value;\n          break;\n        case 'offsetY':\n          value = typeof rawBoxShadow.offsetY === 'string' ? parseLength(rawBoxShadow.offsetY) : rawBoxShadow.offsetY;\n          if (value === null) {\n            return [];\n          }\n          parsedBoxShadow.offsetY = value;\n          break;\n        case 'spreadDistance':\n          value = typeof rawBoxShadow.spreadDistance === 'string' ? parseLength(rawBoxShadow.spreadDistance) : rawBoxShadow.spreadDistance;\n          if (value === null) {\n            return [];\n          }\n          parsedBoxShadow.spreadDistance = value;\n          break;\n        case 'blurRadius':\n          value = typeof rawBoxShadow.blurRadius === 'string' ? parseLength(rawBoxShadow.blurRadius) : rawBoxShadow.blurRadius;\n          if (value === null || value < 0) {\n            return [];\n          }\n          parsedBoxShadow.blurRadius = value;\n          break;\n        case 'color':\n          parsedBoxShadow.color = rawBoxShadow.color;\n          break;\n        case 'inset':\n          parsedBoxShadow.inset = rawBoxShadow.inset;\n      }\n    }\n    result.push(parsedBoxShadow);\n  }\n  props.boxShadow = result;\n}","map":{"version":3,"names":["ReanimatedError","isLength","value","endsWith","isNaN","Number","parseBoxShadowString","rawBoxShadows","result","rawBoxShadow","split","map","bS","trim","filter","boxShadow","offsetX","offsetY","keywordDetectedAfterLength","lengthCount","args","arg","blurRadius","spreadDistance","inset","color","push","parseLength","length","argsWithUnitsRegex","match","exec","processBoxShadow","props","boxShadowList","replace","Array","isArray","JSON","stringify","parsedBoxShadow"],"sources":["/home/runner/work/DemoReception/DemoReception/example/node_modules/react-native-reanimated/src/processBoxShadow.ts"],"sourcesContent":["/* based on:\n * https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/StyleSheet/processBoxShadow.js\n */\n'use strict';\n\n// @ts-ignore BoxShadowValue isn't available in RN 0.75\nimport type { BoxShadowValue, OpaqueColorValue } from 'react-native';\n\nimport type { StyleProps } from '.';\nimport { ReanimatedError } from './errors';\n\nconst isLength = (value: string) => {\n  'worklet';\n  return value.endsWith('px') || !isNaN(Number(value));\n};\n\nfunction parseBoxShadowString(rawBoxShadows: string): Array<BoxShadowValue> {\n  'worklet';\n  const result: Array<BoxShadowValue> = [];\n\n  for (const rawBoxShadow of rawBoxShadows\n    .split(/,(?![^()]*\\))/) // split by comma that is not in parenthesis\n    .map((bS) => bS.trim())\n    .filter((bS) => bS !== '')) {\n    const boxShadow: BoxShadowValue = {\n      offsetX: 0,\n      offsetY: 0,\n    };\n    let offsetX: number | string | null = null;\n    let offsetY: number | string | null = null;\n    let keywordDetectedAfterLength = false;\n\n    let lengthCount = 0;\n\n    // split rawBoxShadow string by all whitespaces that are not in parenthesis\n    const args = rawBoxShadow.split(/\\s+(?![^(]*\\))/);\n    for (const arg of args) {\n      if (isLength(arg)) {\n        switch (lengthCount) {\n          case 0:\n            offsetX = arg;\n            lengthCount++;\n            break;\n          case 1:\n            if (keywordDetectedAfterLength) {\n              return [];\n            }\n            offsetY = arg;\n            lengthCount++;\n            break;\n          case 2:\n            if (keywordDetectedAfterLength) {\n              return [];\n            }\n            boxShadow.blurRadius = arg;\n            lengthCount++;\n            break;\n          case 3:\n            if (keywordDetectedAfterLength) {\n              return [];\n            }\n            boxShadow.spreadDistance = arg;\n            lengthCount++;\n            break;\n          default:\n            return [];\n        }\n      } else if (arg === 'inset') {\n        if (boxShadow.inset) {\n          return [];\n        }\n        if (offsetX !== null) {\n          keywordDetectedAfterLength = true;\n        }\n        boxShadow.inset = true;\n        continue;\n      } else {\n        if (boxShadow.color) {\n          return [];\n        }\n        if (offsetX != null) {\n          keywordDetectedAfterLength = true;\n        }\n        boxShadow.color = arg;\n        continue;\n      }\n    }\n\n    if (offsetX === null || offsetY === null) {\n      return [];\n    }\n\n    boxShadow.offsetX = offsetX;\n    boxShadow.offsetY = offsetY;\n\n    result.push(boxShadow);\n  }\n  return result;\n}\n\nfunction parseLength(length: string): number | null {\n  'worklet';\n  // matches on args with units like \"1.5 5% -80deg\"\n  const argsWithUnitsRegex = /([+-]?\\d*(\\.\\d+)?)([\\w\\W]+)?/g;\n  const match = argsWithUnitsRegex.exec(length);\n\n  if (!match || !isLength(length)) {\n    return null;\n  }\n\n  return Number(match[1]);\n}\n\ntype ParsedBoxShadow = {\n  offsetX: number;\n  offsetY: number;\n  blurRadius?: number | OpaqueColorValue;\n  spreadDistance?: number;\n  inset?: boolean;\n  color?: string;\n};\n\nexport function processBoxShadow(props: StyleProps) {\n  'worklet';\n  const result: Array<ParsedBoxShadow> = [];\n\n  const rawBoxShadows = props.boxShadow;\n\n  if (rawBoxShadows === null) {\n    return result;\n  }\n\n  let boxShadowList: Array<BoxShadowValue>;\n\n  if (typeof rawBoxShadows === 'string') {\n    boxShadowList = parseBoxShadowString(rawBoxShadows.replace(/\\n/g, ' '));\n  } else if (Array.isArray(rawBoxShadows)) {\n    boxShadowList = rawBoxShadows;\n  } else {\n    throw new ReanimatedError(\n      `Box shadow value must be an array of shadow objects or a string. Received: ${JSON.stringify(rawBoxShadows)}`\n    );\n  }\n\n  for (const rawBoxShadow of boxShadowList) {\n    const parsedBoxShadow: ParsedBoxShadow = {\n      offsetX: 0,\n      offsetY: 0,\n    };\n\n    let value;\n    for (const arg in rawBoxShadow) {\n      switch (arg) {\n        case 'offsetX':\n          value =\n            typeof rawBoxShadow.offsetX === 'string'\n              ? parseLength(rawBoxShadow.offsetX)\n              : rawBoxShadow.offsetX;\n          if (value === null) {\n            return [];\n          }\n\n          parsedBoxShadow.offsetX = value;\n          break;\n        case 'offsetY':\n          value =\n            typeof rawBoxShadow.offsetY === 'string'\n              ? parseLength(rawBoxShadow.offsetY)\n              : rawBoxShadow.offsetY;\n          if (value === null) {\n            return [];\n          }\n\n          parsedBoxShadow.offsetY = value;\n          break;\n        case 'spreadDistance':\n          value =\n            typeof rawBoxShadow.spreadDistance === 'string'\n              ? parseLength(rawBoxShadow.spreadDistance)\n              : rawBoxShadow.spreadDistance;\n          if (value === null) {\n            return [];\n          }\n\n          parsedBoxShadow.spreadDistance = value;\n          break;\n        case 'blurRadius':\n          value =\n            typeof rawBoxShadow.blurRadius === 'string'\n              ? parseLength(rawBoxShadow.blurRadius)\n              : (rawBoxShadow.blurRadius as number);\n          if (value === null || value < 0) {\n            return [];\n          }\n\n          parsedBoxShadow.blurRadius = value;\n          break;\n        case 'color':\n          parsedBoxShadow.color = rawBoxShadow.color;\n          break;\n        case 'inset':\n          parsedBoxShadow.inset = rawBoxShadow.inset;\n      }\n    }\n    result.push(parsedBoxShadow);\n  }\n  props.boxShadow = result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}