{"ast":null,"code":"\"use strict\";\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { BaseGesture, Gesture } from \"./gesture\";\nfunction extendRelation(currentRelation, extendWith) {\n  if (currentRelation === undefined) {\n    return _toConsumableArray(extendWith);\n  } else {\n    return [].concat(_toConsumableArray(currentRelation), _toConsumableArray(extendWith));\n  }\n}\nexport var ComposedGesture = function (_Gesture) {\n  _inherits(ComposedGesture, _Gesture);\n  var _super = _createSuper(ComposedGesture);\n  function ComposedGesture() {\n    var _this;\n    _classCallCheck(this, ComposedGesture);\n    _this = _super.call(this);\n    _this.gestures = [];\n    _this.simultaneousGestures = [];\n    _this.requireGesturesToFail = [];\n    for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {\n      gestures[_key] = arguments[_key];\n    }\n    _this.gestures = gestures;\n    return _this;\n  }\n  _createClass(ComposedGesture, [{\n    key: \"prepareSingleGesture\",\n    value: function prepareSingleGesture(gesture, simultaneousGestures, requireGesturesToFail) {\n      if (gesture instanceof BaseGesture) {\n        var newConfig = _objectSpread({}, gesture.config);\n        newConfig.simultaneousWith = extendRelation(newConfig.simultaneousWith, simultaneousGestures);\n        newConfig.requireToFail = extendRelation(newConfig.requireToFail, requireGesturesToFail);\n        gesture.config = newConfig;\n      } else if (gesture instanceof ComposedGesture) {\n        gesture.simultaneousGestures = simultaneousGestures;\n        gesture.requireGesturesToFail = requireGesturesToFail;\n        gesture.prepare();\n      }\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare() {\n      for (var gesture of this.gestures) {\n        this.prepareSingleGesture(gesture, this.simultaneousGestures, this.requireGesturesToFail);\n      }\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      for (var gesture of this.gestures) {\n        gesture.initialize();\n      }\n    }\n  }, {\n    key: \"toGestureArray\",\n    value: function toGestureArray() {\n      return this.gestures.flatMap(function (gesture) {\n        return gesture.toGestureArray();\n      });\n    }\n  }]);\n  return ComposedGesture;\n}(Gesture);\nexport var SimultaneousGesture = function (_ComposedGesture) {\n  _inherits(SimultaneousGesture, _ComposedGesture);\n  var _super2 = _createSuper(SimultaneousGesture);\n  function SimultaneousGesture() {\n    _classCallCheck(this, SimultaneousGesture);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(SimultaneousGesture, [{\n    key: \"prepare\",\n    value: function prepare() {\n      var _this2 = this;\n      var simultaneousArrays = this.gestures.map(function (gesture) {\n        return _this2.gestures.filter(function (x) {\n          return x !== gesture;\n        }).flatMap(function (x) {\n          return x.toGestureArray();\n        });\n      });\n      for (var i = 0; i < this.gestures.length; i++) {\n        this.prepareSingleGesture(this.gestures[i], simultaneousArrays[i], this.requireGesturesToFail);\n      }\n    }\n  }]);\n  return SimultaneousGesture;\n}(ComposedGesture);\nexport var ExclusiveGesture = function (_ComposedGesture2) {\n  _inherits(ExclusiveGesture, _ComposedGesture2);\n  var _super3 = _createSuper(ExclusiveGesture);\n  function ExclusiveGesture() {\n    _classCallCheck(this, ExclusiveGesture);\n    return _super3.apply(this, arguments);\n  }\n  _createClass(ExclusiveGesture, [{\n    key: \"prepare\",\n    value: function prepare() {\n      var gestureArrays = this.gestures.map(function (gesture) {\n        return gesture.toGestureArray();\n      });\n      var requireToFail = [];\n      for (var i = 0; i < this.gestures.length; i++) {\n        this.prepareSingleGesture(this.gestures[i], this.simultaneousGestures, this.requireGesturesToFail.concat(requireToFail));\n        requireToFail = requireToFail.concat(gestureArrays[i]);\n      }\n    }\n  }]);\n  return ExclusiveGesture;\n}(ComposedGesture);","map":{"version":3,"names":["BaseGesture","Gesture","extendRelation","currentRelation","extendWith","undefined","_toConsumableArray","concat","ComposedGesture","_Gesture","_inherits","_super","_createSuper","_this","_classCallCheck","call","gestures","simultaneousGestures","requireGesturesToFail","_len","arguments","length","Array","_key","_createClass","key","value","prepareSingleGesture","gesture","newConfig","_objectSpread","config","simultaneousWith","requireToFail","prepare","initialize","toGestureArray","flatMap","SimultaneousGesture","_ComposedGesture","_super2","apply","_this2","simultaneousArrays","map","filter","x","i","ExclusiveGesture","_ComposedGesture2","_super3","gestureArrays"],"sources":["/home/runner/work/DemoReception/DemoReception/example/node_modules/react-native-gesture-handler/src/handlers/gestures/gestureComposition.ts"],"sourcesContent":["import { BaseGesture, Gesture, GestureRef, GestureType } from './gesture';\n\nfunction extendRelation(\n  currentRelation: GestureRef[] | undefined,\n  extendWith: GestureType[]\n) {\n  if (currentRelation === undefined) {\n    return [...extendWith];\n  } else {\n    return [...currentRelation, ...extendWith];\n  }\n}\n\nexport class ComposedGesture extends Gesture {\n  protected gestures: Gesture[] = [];\n  protected simultaneousGestures: GestureType[] = [];\n  protected requireGesturesToFail: GestureType[] = [];\n\n  constructor(...gestures: Gesture[]) {\n    super();\n    this.gestures = gestures;\n  }\n\n  protected prepareSingleGesture(\n    gesture: Gesture,\n    simultaneousGestures: GestureType[],\n    requireGesturesToFail: GestureType[]\n  ) {\n    if (gesture instanceof BaseGesture) {\n      const newConfig = { ...gesture.config };\n\n      // No need to extend `blocksHandlers` here, because it's not changed in composition.\n      // The same effect is achieved by reversing the order of 2 gestures in `Exclusive`\n      newConfig.simultaneousWith = extendRelation(\n        newConfig.simultaneousWith,\n        simultaneousGestures\n      );\n      newConfig.requireToFail = extendRelation(\n        newConfig.requireToFail,\n        requireGesturesToFail\n      );\n\n      gesture.config = newConfig;\n    } else if (gesture instanceof ComposedGesture) {\n      gesture.simultaneousGestures = simultaneousGestures;\n      gesture.requireGesturesToFail = requireGesturesToFail;\n      gesture.prepare();\n    }\n  }\n\n  prepare() {\n    for (const gesture of this.gestures) {\n      this.prepareSingleGesture(\n        gesture,\n        this.simultaneousGestures,\n        this.requireGesturesToFail\n      );\n    }\n  }\n\n  initialize() {\n    for (const gesture of this.gestures) {\n      gesture.initialize();\n    }\n  }\n\n  toGestureArray(): GestureType[] {\n    return this.gestures.flatMap((gesture) => gesture.toGestureArray());\n  }\n}\n\nexport class SimultaneousGesture extends ComposedGesture {\n  prepare() {\n    // This piece of magic works something like this:\n    // for every gesture in the array\n    const simultaneousArrays = this.gestures.map((gesture) =>\n      // we take the array it's in\n      this.gestures\n        // and make a copy without it\n        .filter((x) => x !== gesture)\n        // then we flatmap the result to get list of raw (not composed) gestures\n        // this way we don't make the gestures simultaneous with themselves, which is\n        // important when the gesture is `ExclusiveGesture` - we don't want to make\n        // exclusive gestures simultaneous\n        .flatMap((x) => x.toGestureArray())\n    );\n\n    for (let i = 0; i < this.gestures.length; i++) {\n      this.prepareSingleGesture(\n        this.gestures[i],\n        simultaneousArrays[i],\n        this.requireGesturesToFail\n      );\n    }\n  }\n}\n\nexport class ExclusiveGesture extends ComposedGesture {\n  prepare() {\n    // Transforms the array of gestures into array of grouped raw (not composed) gestures\n    // i.e. [gesture1, gesture2, ComposedGesture(gesture3, gesture4)] -> [[gesture1], [gesture2], [gesture3, gesture4]]\n    const gestureArrays = this.gestures.map((gesture) =>\n      gesture.toGestureArray()\n    );\n\n    let requireToFail: GestureType[] = [];\n\n    for (let i = 0; i < this.gestures.length; i++) {\n      this.prepareSingleGesture(\n        this.gestures[i],\n        this.simultaneousGestures,\n        this.requireGesturesToFail.concat(requireToFail)\n      );\n\n      // Every group gets to wait for all groups before it\n      requireToFail = requireToFail.concat(gestureArrays[i]);\n    }\n  }\n}\n\nexport type ComposedGestureType = InstanceType<typeof ComposedGesture>;\nexport type RaceGestureType = ComposedGestureType;\nexport type SimultaneousGestureType = InstanceType<typeof SimultaneousGesture>;\nexport type ExclusiveGestureType = InstanceType<typeof ExclusiveGesture>;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}