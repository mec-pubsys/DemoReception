{"ast":null,"code":"'use strict';\n\nimport { blue, green, hsvToColor, opacity, processColor, red, rgbaColor, RGBtoHSV } from \"./Colors.js\";\nimport { makeMutable } from \"./core.js\";\nimport culori from \"./culori/index.js\";\nimport { ReanimatedError } from \"./errors.js\";\nimport { useSharedValue } from \"./hook/useSharedValue.js\";\nimport { Extrapolation, interpolate } from \"./interpolation.js\";\nexport var Extrapolate = Extrapolation;\nvar interpolateColorsHSV = function interpolateColorsHSV(value, inputRange, colors, options) {\n  'worklet';\n\n  var h = 0;\n  var _options$useCorrected = options.useCorrectedHSVInterpolation,\n    useCorrectedHSVInterpolation = _options$useCorrected === void 0 ? true : _options$useCorrected;\n  if (useCorrectedHSVInterpolation) {\n    var correctedInputRange = [inputRange[0]];\n    var originalH = colors.h;\n    var correctedH = [originalH[0]];\n    for (var i = 1; i < originalH.length; ++i) {\n      var d = originalH[i] - originalH[i - 1];\n      if (originalH[i] > originalH[i - 1] && d > 0.5) {\n        correctedInputRange.push(inputRange[i]);\n        correctedInputRange.push(inputRange[i] + 0.00001);\n        correctedH.push(originalH[i] - 1);\n        correctedH.push(originalH[i]);\n      } else if (originalH[i] < originalH[i - 1] && d < -0.5) {\n        correctedInputRange.push(inputRange[i]);\n        correctedInputRange.push(inputRange[i] + 0.00001);\n        correctedH.push(originalH[i] + 1);\n        correctedH.push(originalH[i]);\n      } else {\n        correctedInputRange.push(inputRange[i]);\n        correctedH.push(originalH[i]);\n      }\n    }\n    h = (interpolate(value, correctedInputRange, correctedH, Extrapolation.CLAMP) + 1) % 1;\n  } else {\n    h = interpolate(value, inputRange, colors.h, Extrapolation.CLAMP);\n  }\n  var s = interpolate(value, inputRange, colors.s, Extrapolation.CLAMP);\n  var v = interpolate(value, inputRange, colors.v, Extrapolation.CLAMP);\n  var a = interpolate(value, inputRange, colors.a, Extrapolation.CLAMP);\n  return hsvToColor(h, s, v, a);\n};\nvar toLinearSpace = function toLinearSpace(x, gamma) {\n  'worklet';\n\n  return x.map(function (v) {\n    return Math.pow(v / 255, gamma);\n  });\n};\nvar toGammaSpace = function toGammaSpace(x, gamma) {\n  'worklet';\n\n  return Math.round(Math.pow(x, 1 / gamma) * 255);\n};\nvar interpolateColorsRGB = function interpolateColorsRGB(value, inputRange, colors, options) {\n  'worklet';\n\n  var _options$gamma = options.gamma,\n    gamma = _options$gamma === void 0 ? 2.2 : _options$gamma;\n  var outputR = colors.r,\n    outputG = colors.g,\n    outputB = colors.b;\n  if (gamma !== 1) {\n    outputR = toLinearSpace(outputR, gamma);\n    outputG = toLinearSpace(outputG, gamma);\n    outputB = toLinearSpace(outputB, gamma);\n  }\n  var r = interpolate(value, inputRange, outputR, Extrapolation.CLAMP);\n  var g = interpolate(value, inputRange, outputG, Extrapolation.CLAMP);\n  var b = interpolate(value, inputRange, outputB, Extrapolation.CLAMP);\n  var a = interpolate(value, inputRange, colors.a, Extrapolation.CLAMP);\n  if (gamma === 1) {\n    return rgbaColor(r, g, b, a);\n  }\n  return rgbaColor(toGammaSpace(r, gamma), toGammaSpace(g, gamma), toGammaSpace(b, gamma), a);\n};\nvar interpolateColorsLAB = function interpolateColorsLAB(value, inputRange, colors, _options) {\n  'worklet';\n\n  var l = interpolate(value, inputRange, colors.l, Extrapolation.CLAMP);\n  var a = interpolate(value, inputRange, colors.a, Extrapolation.CLAMP);\n  var b = interpolate(value, inputRange, colors.b, Extrapolation.CLAMP);\n  var alpha = interpolate(value, inputRange, colors.alpha, Extrapolation.CLAMP);\n  var _culori$oklab$convert = culori.oklab.convert.toRgb({\n      l: l,\n      a: a,\n      b: b,\n      alpha: alpha\n    }),\n    _r = _culori$oklab$convert.r,\n    _g = _culori$oklab$convert.g,\n    _b = _culori$oklab$convert.b,\n    _alpha = _culori$oklab$convert.alpha;\n  return rgbaColor(_r, _g, _b, _alpha);\n};\nvar _splitColorsIntoChannels = function _splitColorsIntoChannels(colors, convFromRgb) {\n  'worklet';\n\n  var ch1 = [];\n  var ch2 = [];\n  var ch3 = [];\n  var alpha = [];\n  for (var i = 0; i < colors.length; i++) {\n    var color = colors[i];\n    var processedColor = processColor(color);\n    if (typeof processedColor === 'number') {\n      var convertedColor = convFromRgb({\n        r: red(processedColor),\n        g: green(processedColor),\n        b: blue(processedColor)\n      });\n      ch1.push(convertedColor.ch1);\n      ch2.push(convertedColor.ch2);\n      ch3.push(convertedColor.ch3);\n      alpha.push(opacity(processedColor));\n    }\n  }\n  return {\n    ch1: ch1,\n    ch2: ch2,\n    ch3: ch3,\n    alpha: alpha\n  };\n};\nvar getInterpolateRGB = function getInterpolateRGB(colors) {\n  'worklet';\n\n  var _splitColorsIntoChann = _splitColorsIntoChannels(colors, function (color) {\n      return {\n        ch1: color.r,\n        ch2: color.g,\n        ch3: color.b\n      };\n    }),\n    ch1 = _splitColorsIntoChann.ch1,\n    ch2 = _splitColorsIntoChann.ch2,\n    ch3 = _splitColorsIntoChann.ch3,\n    alpha = _splitColorsIntoChann.alpha;\n  return {\n    r: ch1,\n    g: ch2,\n    b: ch3,\n    a: alpha\n  };\n};\nvar getInterpolateHSV = function getInterpolateHSV(colors) {\n  'worklet';\n\n  var _splitColorsIntoChann2 = _splitColorsIntoChannels(colors, function (color) {\n      var hsvColor = RGBtoHSV(color.r, color.g, color.b);\n      return {\n        ch1: hsvColor.h,\n        ch2: hsvColor.s,\n        ch3: hsvColor.v\n      };\n    }),\n    ch1 = _splitColorsIntoChann2.ch1,\n    ch2 = _splitColorsIntoChann2.ch2,\n    ch3 = _splitColorsIntoChann2.ch3,\n    alpha = _splitColorsIntoChann2.alpha;\n  return {\n    h: ch1,\n    s: ch2,\n    v: ch3,\n    a: alpha\n  };\n};\nvar getInterpolateLAB = function getInterpolateLAB(colors) {\n  'worklet';\n\n  var _splitColorsIntoChann3 = _splitColorsIntoChannels(colors, function (color) {\n      var labColor = culori.oklab.convert.fromRgb(color);\n      return {\n        ch1: labColor.l,\n        ch2: labColor.a,\n        ch3: labColor.b\n      };\n    }),\n    ch1 = _splitColorsIntoChann3.ch1,\n    ch2 = _splitColorsIntoChann3.ch2,\n    ch3 = _splitColorsIntoChann3.ch3,\n    alpha = _splitColorsIntoChann3.alpha;\n  return {\n    l: ch1,\n    a: ch2,\n    b: ch3,\n    alpha: alpha\n  };\n};\nexport function interpolateColor(value, inputRange, outputRange) {\n  'worklet';\n\n  var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'RGB';\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  if (colorSpace === 'HSV') {\n    return interpolateColorsHSV(value, inputRange, getInterpolateHSV(outputRange), options);\n  } else if (colorSpace === 'RGB') {\n    return interpolateColorsRGB(value, inputRange, getInterpolateRGB(outputRange), options);\n  } else if (colorSpace === 'LAB') {\n    return interpolateColorsLAB(value, inputRange, getInterpolateLAB(outputRange), options);\n  }\n  throw new ReanimatedError(`Invalid color space provided: ${colorSpace}. Supported values are: ['RGB', 'HSV', 'LAB'].`);\n}\nexport var ColorSpace = function (ColorSpace) {\n  ColorSpace[ColorSpace[\"RGB\"] = 0] = \"RGB\";\n  ColorSpace[ColorSpace[\"HSV\"] = 1] = \"HSV\";\n  ColorSpace[ColorSpace[\"LAB\"] = 2] = \"LAB\";\n  return ColorSpace;\n}({});\nexport function useInterpolateConfig(inputRange, outputRange) {\n  var colorSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ColorSpace.RGB;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return useSharedValue({\n    inputRange: inputRange,\n    outputRange: outputRange,\n    colorSpace: colorSpace,\n    cache: makeMutable(null),\n    options: options\n  });\n}","map":{"version":3,"names":["blue","green","hsvToColor","opacity","processColor","red","rgbaColor","RGBtoHSV","makeMutable","culori","ReanimatedError","useSharedValue","Extrapolation","interpolate","Extrapolate","interpolateColorsHSV","value","inputRange","colors","options","h","_options$useCorrected","useCorrectedHSVInterpolation","correctedInputRange","originalH","correctedH","i","length","d","push","CLAMP","s","v","a","toLinearSpace","x","gamma","map","Math","pow","toGammaSpace","round","interpolateColorsRGB","_options$gamma","outputR","r","outputG","g","outputB","b","interpolateColorsLAB","_options","l","alpha","_culori$oklab$convert","oklab","convert","toRgb","_r","_g","_b","_alpha","_splitColorsIntoChannels","convFromRgb","ch1","ch2","ch3","color","processedColor","convertedColor","getInterpolateRGB","_splitColorsIntoChann","getInterpolateHSV","_splitColorsIntoChann2","hsvColor","getInterpolateLAB","_splitColorsIntoChann3","labColor","fromRgb","interpolateColor","outputRange","colorSpace","arguments","undefined","ColorSpace","useInterpolateConfig","RGB","cache"],"sources":["/home/runner/work/DemoReception/DemoReception/example/node_modules/react-native-reanimated/src/interpolateColor.ts"],"sourcesContent":["'use strict';\nimport {\n  blue,\n  green,\n  hsvToColor,\n  opacity,\n  processColor,\n  red,\n  rgbaColor,\n  RGBtoHSV,\n} from './Colors';\nimport type { SharedValue } from './commonTypes';\nimport { makeMutable } from './core';\nimport culori from './culori';\nimport { ReanimatedError } from './errors';\nimport { useSharedValue } from './hook/useSharedValue';\nimport { Extrapolation, interpolate } from './interpolation';\n\n/** @deprecated Please use Extrapolation instead */\nexport const Extrapolate = Extrapolation;\n\n/**\n * Options for color interpolation.\n *\n * @param gamma - Gamma value used in gamma correction. Defaults to `2.2`.\n * @param useCorrectedHSVInterpolation - Whether to reduce the number of colors\n *   the interpolation has to go through. Defaults to `true`.\n */\nexport type InterpolationOptions = {\n  gamma?: number;\n  useCorrectedHSVInterpolation?: boolean;\n};\n\nconst interpolateColorsHSV = (\n  value: number,\n  inputRange: readonly number[],\n  colors: InterpolateHSV,\n  options: InterpolationOptions\n) => {\n  'worklet';\n  let h = 0;\n  const { useCorrectedHSVInterpolation = true } = options;\n  if (useCorrectedHSVInterpolation) {\n    // if the difference between hues in a range is > 180 deg\n    // then move the hue at the right end of the range +/- 360 deg\n    // and add the next point in the original place + 0.00001 with original hue\n    // to not break the next range\n    const correctedInputRange = [inputRange[0]];\n    const originalH = colors.h;\n    const correctedH = [originalH[0]];\n\n    for (let i = 1; i < originalH.length; ++i) {\n      const d = originalH[i] - originalH[i - 1];\n      if (originalH[i] > originalH[i - 1] && d > 0.5) {\n        correctedInputRange.push(inputRange[i]);\n        correctedInputRange.push(inputRange[i] + 0.00001);\n        correctedH.push(originalH[i] - 1);\n        correctedH.push(originalH[i]);\n      } else if (originalH[i] < originalH[i - 1] && d < -0.5) {\n        correctedInputRange.push(inputRange[i]);\n        correctedInputRange.push(inputRange[i] + 0.00001);\n        correctedH.push(originalH[i] + 1);\n        correctedH.push(originalH[i]);\n      } else {\n        correctedInputRange.push(inputRange[i]);\n        correctedH.push(originalH[i]);\n      }\n    }\n    h =\n      (interpolate(\n        value,\n        correctedInputRange,\n        correctedH,\n        Extrapolation.CLAMP\n      ) +\n        1) %\n      1;\n  } else {\n    h = interpolate(value, inputRange, colors.h, Extrapolation.CLAMP);\n  }\n  const s = interpolate(value, inputRange, colors.s, Extrapolation.CLAMP);\n  const v = interpolate(value, inputRange, colors.v, Extrapolation.CLAMP);\n  const a = interpolate(value, inputRange, colors.a, Extrapolation.CLAMP);\n  return hsvToColor(h, s, v, a);\n};\n\nconst toLinearSpace = (x: number[], gamma: number): number[] => {\n  'worklet';\n  return x.map((v) => Math.pow(v / 255, gamma));\n};\n\nconst toGammaSpace = (x: number, gamma: number): number => {\n  'worklet';\n  return Math.round(Math.pow(x, 1 / gamma) * 255);\n};\n\nconst interpolateColorsRGB = (\n  value: number,\n  inputRange: readonly number[],\n  colors: InterpolateRGB,\n  options: InterpolationOptions\n) => {\n  'worklet';\n  const { gamma = 2.2 } = options;\n  let { r: outputR, g: outputG, b: outputB } = colors;\n  if (gamma !== 1) {\n    outputR = toLinearSpace(outputR, gamma);\n    outputG = toLinearSpace(outputG, gamma);\n    outputB = toLinearSpace(outputB, gamma);\n  }\n  const r = interpolate(value, inputRange, outputR, Extrapolation.CLAMP);\n  const g = interpolate(value, inputRange, outputG, Extrapolation.CLAMP);\n  const b = interpolate(value, inputRange, outputB, Extrapolation.CLAMP);\n  const a = interpolate(value, inputRange, colors.a, Extrapolation.CLAMP);\n  if (gamma === 1) {\n    return rgbaColor(r, g, b, a);\n  }\n  return rgbaColor(\n    toGammaSpace(r, gamma),\n    toGammaSpace(g, gamma),\n    toGammaSpace(b, gamma),\n    a\n  );\n};\n\nconst interpolateColorsLAB = (\n  value: number,\n  inputRange: readonly number[],\n  colors: InterpolateLAB,\n  _options: InterpolationOptions\n) => {\n  'worklet';\n  const l = interpolate(value, inputRange, colors.l, Extrapolation.CLAMP);\n  const a = interpolate(value, inputRange, colors.a, Extrapolation.CLAMP);\n  const b = interpolate(value, inputRange, colors.b, Extrapolation.CLAMP);\n  const alpha = interpolate(\n    value,\n    inputRange,\n    colors.alpha,\n    Extrapolation.CLAMP\n  );\n  const {\n    r: _r,\n    g: _g,\n    b: _b,\n    alpha: _alpha,\n  } = culori.oklab.convert.toRgb({ l, a, b, alpha });\n  return rgbaColor(_r, _g, _b, _alpha);\n};\n\nconst _splitColorsIntoChannels = (\n  colors: readonly (string | number)[],\n  convFromRgb: (color: { r: number; g: number; b: number }) => {\n    ch1: number;\n    ch2: number;\n    ch3: number;\n  }\n): {\n  ch1: number[];\n  ch2: number[];\n  ch3: number[];\n  alpha: number[];\n} => {\n  'worklet';\n  const ch1: number[] = [];\n  const ch2: number[] = [];\n  const ch3: number[] = [];\n  const alpha: number[] = [];\n\n  for (let i = 0; i < colors.length; i++) {\n    const color = colors[i];\n    const processedColor = processColor(color);\n    if (typeof processedColor === 'number') {\n      const convertedColor = convFromRgb({\n        r: red(processedColor),\n        g: green(processedColor),\n        b: blue(processedColor),\n      });\n\n      ch1.push(convertedColor.ch1);\n      ch2.push(convertedColor.ch2);\n      ch3.push(convertedColor.ch3);\n      alpha.push(opacity(processedColor));\n    }\n  }\n\n  return {\n    ch1,\n    ch2,\n    ch3,\n    alpha,\n  };\n};\n\nexport interface InterpolateRGB {\n  r: number[];\n  g: number[];\n  b: number[];\n  a: number[];\n}\n\nconst getInterpolateRGB = (\n  colors: readonly (string | number)[]\n): InterpolateRGB => {\n  'worklet';\n  const { ch1, ch2, ch3, alpha } = _splitColorsIntoChannels(\n    colors,\n    (color) => ({\n      ch1: color.r,\n      ch2: color.g,\n      ch3: color.b,\n    })\n  );\n\n  return {\n    r: ch1,\n    g: ch2,\n    b: ch3,\n    a: alpha,\n  };\n};\n\nexport interface InterpolateHSV {\n  h: number[];\n  s: number[];\n  v: number[];\n  a: number[];\n}\n\nconst getInterpolateHSV = (\n  colors: readonly (string | number)[]\n): InterpolateHSV => {\n  'worklet';\n  const { ch1, ch2, ch3, alpha } = _splitColorsIntoChannels(colors, (color) => {\n    const hsvColor = RGBtoHSV(color.r, color.g, color.b);\n    return {\n      ch1: hsvColor.h,\n      ch2: hsvColor.s,\n      ch3: hsvColor.v,\n    };\n  });\n\n  return {\n    h: ch1,\n    s: ch2,\n    v: ch3,\n    a: alpha,\n  };\n};\n\nexport interface InterpolateLAB {\n  l: number[];\n  a: number[];\n  b: number[];\n  alpha: number[];\n}\n\nconst getInterpolateLAB = (\n  colors: readonly (string | number)[]\n): InterpolateLAB => {\n  'worklet';\n\n  const { ch1, ch2, ch3, alpha } = _splitColorsIntoChannels(colors, (color) => {\n    const labColor = culori.oklab.convert.fromRgb(color);\n    return {\n      ch1: labColor.l,\n      ch2: labColor.a,\n      ch3: labColor.b,\n    };\n  });\n\n  return {\n    l: ch1,\n    a: ch2,\n    b: ch3,\n    alpha,\n  };\n};\n\n/**\n * Lets you map a value from a range of numbers to a range of colors using\n * linear interpolation.\n *\n * @param value - A number from the `input` range that is going to be mapped to\n *   the color in the `output` range.\n * @param inputRange - An array of numbers specifying the input range of the\n *   interpolation.\n * @param outputRange - An array of output colors values (eg. \"red\", \"#00FFCC\",\n *   \"rgba(255, 0, 0, 0.5)\").\n * @param colorSpace - The color space to use for interpolation. Defaults to\n *   'RGB'.\n * @param options - Additional options for interpolation -\n *   {@link InterpolationOptions}.\n * @returns The color after interpolation from within the output range in\n *   rgba(r, g, b, a) format.\n * @see https://docs.swmansion.com/react-native-reanimated/docs/utilities/interpolateColor\n */\nexport function interpolateColor(\n  value: number,\n  inputRange: readonly number[],\n  outputRange: readonly string[],\n  colorSpace?: 'RGB' | 'HSV' | 'LAB',\n  options?: InterpolationOptions\n): string;\n\nexport function interpolateColor(\n  value: number,\n  inputRange: readonly number[],\n  outputRange: readonly number[],\n  colorSpace?: 'RGB' | 'HSV' | 'LAB',\n  options?: InterpolationOptions\n): number;\n\nexport function interpolateColor(\n  value: number,\n  inputRange: readonly number[],\n  outputRange: readonly (string | number)[],\n  colorSpace: 'RGB' | 'HSV' | 'LAB' = 'RGB',\n  options: InterpolationOptions = {}\n): string | number {\n  'worklet';\n  if (colorSpace === 'HSV') {\n    return interpolateColorsHSV(\n      value,\n      inputRange,\n      getInterpolateHSV(outputRange),\n      options\n    );\n  } else if (colorSpace === 'RGB') {\n    return interpolateColorsRGB(\n      value,\n      inputRange,\n      getInterpolateRGB(outputRange),\n      options\n    );\n  } else if (colorSpace === 'LAB') {\n    return interpolateColorsLAB(\n      value,\n      inputRange,\n      getInterpolateLAB(outputRange),\n      options\n    );\n  }\n\n  throw new ReanimatedError(\n    `Invalid color space provided: ${\n      colorSpace as string\n    }. Supported values are: ['RGB', 'HSV', 'LAB'].`\n  );\n}\n\nexport enum ColorSpace {\n  RGB = 0,\n  HSV = 1,\n  LAB = 2,\n}\n\nexport interface InterpolateConfig {\n  inputRange: readonly number[];\n  outputRange: readonly (string | number)[];\n  colorSpace: ColorSpace;\n  cache: SharedValue<InterpolateRGB | InterpolateHSV | null>;\n  options: InterpolationOptions;\n}\n\nexport function useInterpolateConfig(\n  inputRange: readonly number[],\n  outputRange: readonly (string | number)[],\n  colorSpace = ColorSpace.RGB,\n  options: InterpolationOptions = {}\n): SharedValue<InterpolateConfig> {\n  return useSharedValue<InterpolateConfig>({\n    inputRange,\n    outputRange,\n    colorSpace,\n    cache: makeMutable<InterpolateRGB | InterpolateHSV | null>(null),\n    options,\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}